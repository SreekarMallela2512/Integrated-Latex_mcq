<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>LaTeX MCQ Input</title>
  <link rel="stylesheet" href="style.css" />
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
 <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
  <div class="container">
    <!-- User Info Bar -->
    <div class="user-info-bar">
      <div class="user-info">
        <span id="welcomeMessage">Loading...</span>
        <span id="userRole" class="role-badge"></span>
      </div>
      <button id="logoutBtn" class="logout-btn">Logout</button>
    </div>
<!-- Add this section in index.html after the user-info-bar div and before the h1 tag -->

<!-- Admin Management Section (Only visible to superusers) -->
<div id="adminSection" class="admin-section" style="display: none;">
  <h2>üîß Admin Management</h2>
  
  <!-- Year Management -->
  <div class="admin-card">
    <h3>üìÖ Year Management</h3>
    <div class="admin-controls">
      <div class="input-group">
        <input type="number" id="newYear" placeholder="Add new year (e.g., 2026)" min="1000" />
        <button onclick="addYear()" class="admin-btn add-btn">‚ûï Add Year</button>
      </div>
      <div class="year-list">
        <h4>Current Years:</h4>
        <div id="yearsList"></div>
      </div>
    </div>
  </div>
  
  <!-- Exam Date Management -->
  <div class="admin-card">
    <h3>üìù Exam Date Management</h3>
    <div class="admin-controls">
      <div class="input-group">
        <select id="dateManagementYear" onchange="loadExamDatesForYear()">
          <option value="">Select Year</option>
        </select>
        <input type="date" id="newExamDate" />
        <button onclick="addExamDate()" class="admin-btn add-btn">‚ûï Add Date</button>
      </div>
      <div class="exam-dates-list">
        <h4>Exam Dates for Selected Year:</h4>
        <div id="examDatesList"></div>
      </div>
    </div>
  </div>
  
  <button onclick="toggleAdminSection()" class="admin-toggle-btn">Hide Admin Panel</button>
</div>

<!-- Admin Toggle Button (Only visible to superusers) -->
<button id="adminToggleBtn" onclick="toggleAdminSection()" class="admin-toggle-btn" style="display: none;">
  Show Admin Panel
</button>
    <h1>Submit MCQ (LaTeX Supported)</h1>

    <form id="mcqForm" method="POST">
    <label>Question Number:</label>
<input type="text" name="questionNo" id="questionNo" placeholder="e.g., Q1, 1, A-1, etc." required />
<span id="serialNumberInfo" style="font-size: 0.8em; color: #666; display: block; margin-top: 5px;">
  For PYQ questions, this will be auto-generated
</span>
      <label>Question (LaTeX):</label>
      <textarea name="question" id="question" rows="3" oninput="renderLatex()" required></textarea>
      <h3>Preview:</h3>
      <div id="preview"></div>
      
      <label>Option 1:</label>
      <input type="text" name="option1" id="option1" required oninput="renderOptionLatex(1)" />
      <div class="option-preview" id="preview-option1"></div>

      <label>Option 2:</label>
      <input type="text" name="option2" id="option2" required oninput="renderOptionLatex(2)" />
      <div class="option-preview" id="preview-option2"></div>

      <label>Option 3:</label>
      <input type="text" name="option3" id="option3" required oninput="renderOptionLatex(3)" />
      <div class="option-preview" id="preview-option3"></div>

      <label>Option 4:</label>
      <input type="text" name="option4" id="option4" required oninput="renderOptionLatex(4)" />
      <div class="option-preview" id="preview-option4"></div>

      <label>Correct Option (1-4):</label>
      <input type="number" name="correctOption" min="1" max="4" required>

      <label for="subject">Subject:</label>
      <select name="subject" id="subject" required onchange="updateTopics()">
        <option value="">-- Select Subject --</option>
        <option value="Maths">Maths</option>
        <option value="Physics">Physics</option>
        <option value="Chemistry">Chemistry</option>
      </select>

      <label for="topic">Topic:</label>
      <select name="topic" id="topic" required>
        <option value="">-- Select Topic --</option>
      </select>

      <label for="difficulty">Difficulty:</label>
      <!-- Replace the existing difficulty dropdown with this -->
<div class="difficulty-display">
  <input type="text" name="difficulty" id="difficulty" readonly 
         placeholder="Will be auto-classified..." 
         style="background-color: #f0f0f0; cursor: not-allowed;">
  <span id="classificationStatus" style="font-size: 0.8em; color: #666; margin-left: 10px;"></span>
  <button type="button" onclick="reclassifyDifficulty()" style="margin-left: 10px; padding: 5px 10px;">
    üîÑ Re-classify
  </button>
</div>
<!-- Add this after the difficulty field in your form -->
<label for="solution">Solution (LaTeX):</label>
<textarea name="solution" id="solution" rows="5" oninput="renderSolutionLatex()" 
          placeholder="Enter the detailed solution here. You can use LaTeX for mathematical expressions."></textarea>
<h3>Solution Preview:</h3>
<div id="solution-preview" class="solution-preview">
  <em style="color: #777;">Solution preview will appear here...</em>
</div>
      <!-- PYQ Section -->
      <div class="pyq-section">
        <h3>Previous Year Question (PYQ) Details</h3>
        
        <label for="pyqType">PYQ Type:</label>
        <select name="pyqType" id="pyqType" onchange="togglePyqFields()" required>
          <option value="Not PYQ">Not PYQ</option>
          <option value="JEE MAIN PYQ">JEE MAIN PYQ</option>
        </select>

        <div id="pyqDetails" style="display: none;">
        

          <!-- Year selection -->
          <label for="year">Year:</label>
        <!-- REPLACE WITH EMPTY DROPDOWN -->
<select name="year" id="year" onchange="populateExamDates()">
  <option value="">-- Select Year --</option>
</select>
          <!-- Exam Date selection -->
          <label for="examDate">Exam Date:</label>
<select name="examDate" id="examDate" onchange="updateQuestionNumber()">
  <option value="">-- Select Exam Date --</option>
</select>
          <!-- Shift selection -->
          <div id="shiftSection">
  <label>Shift:</label>
  <div class="radio-group">
    <label class="radio-label">
      <input type="radio" name="shift" value="Shift 1" onchange="updateQuestionNumber()" />
      Shift 1
    </label>
    <label class="radio-label">
      <input type="radio" name="shift" value="Shift 2" onchange="updateQuestionNumber()" />
      Shift 2
    </label>
  </div>
</div>

        </div>
      </div>

      <button type="submit">Save</button>
      <button type="button" onclick="clearForm()">Clear Form</button>
      <div id="successMessage"></div>
    </form>
    
    <hr />
    <h2 id="questionsTitle">Your Questions</h2>
    <!-- Replace the existing view questions button and questionList with this complete section -->
<button onclick="loadQuestions()" class="view-questions-btn">üîç View Questions</button>

<!-- Search and Filter Container -->
<div class="search-filter-container" id="searchFilterContainer" style="display: none;">
  <!-- Search Bar -->
  <div class="search-section">
    <input 
      type="text" 
      id="searchInput" 
      placeholder="üîç Search questions, options, topics..." 
      class="search-bar"
      onkeypress="if(event.key === 'Enter') searchQuestions()"
    />
    <button onclick="searchQuestions()" class="search-btn">Search</button>
    <button onclick="clearSearch()" class="clear-search-btn">Clear</button>
  </div>

  <!-- Filter Toggle Button -->
  <button onclick="toggleFilters()" class="filter-toggle-btn">
    <span id="filterToggleIcon">‚ñº</span> Filters
    <span id="activeFilterCount" class="filter-count" style="display: none;">0</span>
  </button>
</div>

<!-- Advanced Filters Section -->
<div id="filterSection" class="filter-section" style="display: none;">
  <div class="filter-grid">
    <!-- Subject Filter -->
    <div class="filter-group">
      <label>Subject:</label>
      <select id="filterSubject" onchange="updateTopicFilter(); applyFilters();">
        <option value="">All Subjects</option>
        <option value="Physics">Physics</option>
        <option value="Chemistry">Chemistry</option>
        <option value="Maths">Maths</option>
      </select>
    </div>

    <!-- Topic Filter -->
    <div class="filter-group">
      <label>Topic:</label>
      <select id="filterTopic" onchange="applyFilters()">
        <option value="">All Topics</option>
      </select>
    </div>

    <!-- Difficulty Filter -->
    <div class="filter-group">
      <label>Difficulty:</label>
      <select id="filterDifficulty" onchange="applyFilters()">
        <option value="">All Difficulties</option>
        <option value="easy">Easy</option>
        <option value="medium">Medium</option>
        <option value="hard">Hard</option>
      </select>
    </div>

    <!-- PYQ Type Filter -->
    <div class="filter-group">
      <label>PYQ Type:</label>
      <select id="filterPyqType" onchange="applyFilters()">
        <option value="">All Types</option>
        <option value="Not PYQ">Not PYQ</option>
        <option value="JEE MAIN PYQ">JEE MAIN PYQ</option>
      </select>
    </div>

    <!-- Year Filter -->
    <div class="filter-group">
      <label>Year:</label>
      <select id="filterYear" onchange="applyFilters()">
        <option value="">All Years</option>
      </select>
    </div>

    <!-- Sort Options -->
    <div class="filter-group">
      <label>Sort By:</label>
      <select id="sortBy" onchange="applyFilters()">
        <option value="createdAt-desc">Newest First</option>
        <option value="createdAt-asc">Oldest First</option>
        <option value="questionNo-asc">Question No. (A-Z)</option>
        <option value="questionNo-desc">Question No. (Z-A)</option>
        <option value="difficulty-asc">Difficulty (Easy ‚Üí Hard)</option>
        <option value="difficulty-desc">Difficulty (Hard ‚Üí Easy)</option>
      </select>
    </div>

    <!-- Creator Filter (Superuser only) -->
    <div class="filter-group" id="creatorFilterGroup" style="display: none;">
      <label>Created By:</label>
      <select id="filterCreator" onchange="applyFilters()">
        <option value="">All Users</option>
      </select>
    </div>
  </div>

  <!-- Filter Actions -->
  <div class="filter-actions">
    <button onclick="resetFilters()" class="reset-filters-btn">Reset All Filters</button>
  </div>
</div>

<!-- Results Summary -->
<div id="resultsSummary" class="results-summary" style="display: none;">
  Showing <span id="resultsCount">0</span> questions
  <span id="searchSummary"></span>
</div>

<!-- Question List -->
<div id="questionList"></div>
    <button type="button" onclick="cancelEdit()" id="cancelEditBtn" style="display: none;">Cancel Edit</button>
  </div>

  <script>
    let currentUser = null;
    let editMode = false;
    let editingQuestionId = null;
    let wasAutoClassified = false;
    // Add this at the very top with other variables
let previewTimeout;
    // Add this at the very top with other variables

    
    // Global variables for search and filter
    let allQuestions = [];
    let filteredQuestions = [];
    let currentSearchTerm = '';
    let activeFilters = {
      subject: '',
      topic: '',
      difficulty: '',
      pyqType: '',
      year: '',
      creator: '',
      sortBy: 'createdAt-desc'
    };
    
    const CLASSIFIER_API_URL = 'https://mcq-classifier-g1z9.onrender.com';
    
    // Topic arrays
    const physicsTopics = ["Physical World and Measurement", "Kinematics", "Laws of Motion", "Work, Energy and Power", "Rotational Motion", "Gravitation", "Properties of Solids and Liquids", "Thermodynamics", "Kinetic Theory of Gases", "Oscillations and Waves", "Electrostatics", "Current Electricity", "Magnetic Effects of Current and Magnetism", "Electromagnetic Induction and Alternating Currents", "Electromagnetic Waves", "Optics", "Dual Nature of Matter and Radiation", "Atoms and Nuclei", "Electronic Devices", "Communication Systems"];

    const chemistryTopics = ["Some Basic Concepts of Chemistry (Mole Concept)", "Atomic Structure", "Chemical Bonding and Molecular Structure", "Chemical Thermodynamics", "Solutions", "Equilibrium", "Redox Reactions and Electrochemistry", "Chemical Kinetics", "Surface Chemistry", "Classification of Elements and Periodicity in Properties", "General Principles and Processes of Isolation of Metals", "Hydrogen", "S-block elements (Alkali and Alkaline earth metals)", "P-block elements", "D and F block elements", "Coordination Compounds", "Environmental Chemistry", "Organic Chemistry ‚Äì Basic Principles and Techniques", "Hydrocarbons", "Haloalkanes and Haloarenes", "Alcohols, Phenols, and Ethers", "Aldehydes, Ketones, and Carboxylic Acids", "Organic Compounds Containing Nitrogen", "Polymers", "Biomolecules", "Solid States"];

    const mathsTopics = ["Sets, Relations and Functions", "Complex Numbers and Quadratic Equations", "Matrices and Determinants", "Permutations and Combinations", "Mathematical Induction", "Binomial Theorem", "Sequences and Series", "Limits, Continuity and Differentiability", "Integral Calculus", "Differential Equations", "Coordinate Geometry", "3D Geometry", "Vector Algebra", "Statistics and Probability", "Trigonometry", "Mathematical Reasoning"];
    // Add these variables at the top with other global variables
let questionCountCache = {};

// Function to generate unique serial number
async function generateUniqueSerialNumber() {
  const pyqType = document.getElementById('pyqType').value;
  if (pyqType !== 'JEE MAIN PYQ') return null;

  const year = document.getElementById('year').value;
  const examDate = document.getElementById('examDate').value;
  const shiftRadio = document.querySelector('input[name="shift"]:checked');
  if (!year || !examDate || !shiftRadio) return null;

  const shift = shiftRadio.value;

  try {
    const response = await fetch(`/generate-serial/${year}/${examDate}/${shift}`);
    if (!response.ok) throw new Error('Failed to generate serial');

    const { serial } = await response.json();
    return serial;
  } catch (error) {
    console.error('Serial generation error:', error);
    return `FALLBACK-${Date.now()}`; // fallback in extreme case
  }
}
// Function to render solution LaTeX
function renderSolutionLatex() {
  clearTimeout(previewTimeout);

  previewTimeout = setTimeout(() => {
    const input = document.getElementById('solution').value.trim();
    const preview = document.getElementById('solution-preview');

    if (!input) {
      preview.innerHTML = '<em style="color: #777;">Solution preview will appear here...</em>';
      return;
    }

    // Process LaTeX content
    let processed = processLatexContent(input, true);
    preview.innerHTML = processed;

    // Render with MathJax
    MathJax.typesetClear([preview]);
    MathJax.typesetPromise([preview]).catch(err => {
      preview.innerHTML = '<span style="color:red;">LaTeX rendering error.</span>';
      console.error('MathJax error:', err);
    });
  }, 500);
}
// Function to update question number field
async function updateQuestionNumber() {
  const pyqType = document.getElementById('pyqType').value;
  const questionNoInput = document.getElementById('questionNo');
  
  if (pyqType === 'JEE MAIN PYQ') {
    // Check if all required fields are filled
    const year = document.getElementById('year').value;
    const examDate = document.getElementById('examDate').value;
    const shiftRadio = document.querySelector('input[name="shift"]:checked');
    
    if (year && examDate && shiftRadio) {
      // Generate serial number
      const serialNumber = await generateUniqueSerialNumber();
      
      if (serialNumber) {
        questionNoInput.value = serialNumber;
        questionNoInput.readOnly = true;
        questionNoInput.style.backgroundColor = '#f0f0f0';
        questionNoInput.style.cursor = 'not-allowed';
        
        // Add visual feedback
        questionNoInput.style.borderColor = '#4caf50';
        setTimeout(() => {
          questionNoInput.style.borderColor = '';
        }, 2000);
      }
    } else {
      // Clear the field if required fields are not complete
      questionNoInput.value = '';
      questionNoInput.placeholder = 'Complete PYQ details to generate';
    }
  } else {
    // For non-PYQ questions, allow manual input
    questionNoInput.value = '';
    questionNoInput.readOnly = false;
    questionNoInput.style.backgroundColor = '';
    questionNoInput.style.cursor = '';
    questionNoInput.placeholder = 'e.g., Q1, 1, A-1, etc.';
  }
}
    // Function to edit a question (superuser only)
    async function editQuestion(questionId) {
      if (currentUser.role !== 'superuser') {
        alert('Only superusers can edit questions.');
        return;
      }

      try {
        const response = await fetch(`/questions/${questionId}`);
        if (!response.ok) {
          throw new Error('Failed to fetch question details');
        }
        
        const question = await response.json();
        
        // Enable edit mode
        editMode = true;
        editingQuestionId = questionId;
        
        // Update form title and button
        document.querySelector('h1').textContent = 'Edit MCQ (LaTeX Supported)';
        document.querySelector('button[type="submit"]').textContent = 'Update Question';
        
        // Populate form with existing data
        document.getElementById('questionNo').value = question.questionNo;
        document.getElementById('question').value = question.question;
        document.getElementById('option1').value = question.options[0] || '';
        document.getElementById('option2').value = question.options[1] || '';
        document.getElementById('option3').value = question.options[2] || '';
        document.getElementById('option4').value = question.options[3] || '';
        document.querySelector('input[name="correctOption"]').value = question.correctOption + 1;
        document.getElementById('subject').value = question.subject;
        document.getElementById('solution').value = question.solution || '';
        renderSolutionLatex();
        // Update topics based on subject
        updateTopics();
        setTimeout(() => {
          document.getElementById('topic').value = question.topic;
        }, 100);
        
        document.getElementById('difficulty').value = question.difficulty;
        document.getElementById('pyqType').value = question.pyqType;
        
        // Handle PYQ details
        if (question.pyqType === 'JEE MAIN PYQ') {
          togglePyqFields();
          document.getElementById('year').value = question.year;
          populateExamDates();
          
          setTimeout(() => {
            if (question.examDate) {
              const examDateFormatted = new Date(question.examDate).toISOString().split('T')[0];
              document.getElementById('examDate').value = examDateFormatted;
            }
            
            if (question.shift) {
              const shiftRadio = document.querySelector(`input[name="shift"][value="${question.shift}"]`);
              if (shiftRadio) {
                shiftRadio.checked = true;
              }
            }
          }, 200);
        }
        
        // Render LaTeX previews
        renderLatex();
        for (let i = 1; i <= 4; i++) {
          renderOptionLatex(i);
        }
        
        // Scroll to form
        document.querySelector('h1').scrollIntoView({ behavior: 'smooth' });
        
      } catch (error) {
        console.error('Error loading question for edit:', error);
        alert('Error loading question for editing.');
      }
    }

    // Function to cancel edit mode
    function cancelEdit() {
      editMode = false;
      editingQuestionId = null;
      document.querySelector('h1').textContent = 'Submit MCQ (LaTeX Supported)';
      document.querySelector('button[type="submit"]').textContent = 'Save';
      clearForm();
    }

    // Function to delete a question (superuser only)
    async function deleteQuestion(questionId) {
      if (currentUser.role !== 'superuser') {
        alert('Only superusers can delete questions.');
        return;
      }

      if (!confirm('Are you sure you want to delete this question? This action cannot be undone.')) {
        return;
      }

      try {
        const response = await fetch(`/questions/${questionId}`, {
          method: 'DELETE'
        });

        if (response.ok) {
          alert('Question deleted successfully!');
          loadQuestions(); // Reload the questions list
        } else {
          const errorText = await response.text();
          alert('Failed to delete question: ' + errorText);
        }
      } catch (error) {
        console.error('Error deleting question:', error);
        alert('Error deleting question.');
      }
    }

    // Check authentication on page load
    window.onload = async () => {
      try {
        const response = await fetch('/auth/status');
        const data = await response.json();
        
        if (!data.authenticated) {
          window.location.href = '/login.html';
          return;
        }
        
        currentUser = data.user;
        updateUserInterface();
        
        // Add classification status indicator
        addClassificationStatus();
        
        // Always load years for all users
        await loadYears();
        
        // Setup batch classification for superusers
        if (currentUser.role === 'superuser') {
          setupBatchClassification();
        }

      } catch (error) {
        window.location.href = '/login.html';
      }
    };

    function updateUserInterface() {
      document.getElementById('welcomeMessage').textContent = `Welcome, ${currentUser.username}!`;
      const roleElement = document.getElementById('userRole');
      roleElement.textContent = currentUser.role === 'superuser' ? 'Super User' : 'User';
      roleElement.className = `role-badge ${currentUser.role}`;

      const questionsTitle = document.getElementById('questionsTitle');
      questionsTitle.textContent = currentUser.role === 'superuser' ? 'All Questions' : 'Your Questions';

      // Show admin features for superusers
      if (currentUser.role === 'superuser') {
        document.getElementById('adminToggleBtn').style.display = 'block';
      } else {
        // For regular users, still load basic years for the PYQ dropdown
        const defaultYears = [2025, 2024, 2023, 2022, 2021];
        updateMainPyqYearDropdown(defaultYears);
      }
    }

    // Populate exam dates based on selected year
   async function populateExamDates() {
  const year = document.getElementById('year').value;
  const examDateSelect = document.getElementById('examDate');

  // Clear existing options
  examDateSelect.innerHTML = '<option value="">-- Select Exam Date --</option>';

  if (!year) {
    examDateSelect.required = false;
    updateQuestionNumber(); // Update serial number
    return;
  }

  try {
    // Always use public endpoint for exam dates
    const response = await fetch(`/public/exam-dates/${year}`);
    if (!response.ok) throw new Error('Failed to load exam dates');

    const examDates = await response.json();
    examDates.forEach(dateObj => {
      const option = document.createElement('option');
      option.value = dateObj.date;
      option.textContent = dateObj.label;
      examDateSelect.appendChild(option);
    });

    examDateSelect.required = true;
  } catch (err) {
    console.error('Error loading exam dates:', err);
    examDateSelect.required = false;
  }
  
  // Update serial number
  updateQuestionNumber();
}

       // Toggle PYQ fields based on selection
    function togglePyqFields() {
  const pyqType = document.getElementById('pyqType').value;
  const pyqDetails = document.getElementById('pyqDetails');
  const yearSelect = document.getElementById('year');
  const examDateSelect = document.getElementById('examDate');
  const questionNoInput = document.getElementById('questionNo');
  
  if (pyqType === 'Not PYQ') {
    pyqDetails.style.display = 'none';
    yearSelect.required = false;
    examDateSelect.required = false;
    // Clear radio buttons
    document.querySelectorAll('input[name="shift"]').forEach(radio => {
      radio.checked = false;
      radio.required = false;
    });
    
    // Reset question number field for manual input
    questionNoInput.value = '';
    questionNoInput.readOnly = false;
    questionNoInput.style.backgroundColor = '';
    questionNoInput.style.cursor = '';
    questionNoInput.placeholder = 'e.g., Q1, 1, A-1, etc.';
  } else {
    pyqDetails.style.display = 'block';
    yearSelect.required = true;
    document.querySelectorAll('input[name="shift"]').forEach(radio => {
      radio.required = true;
    });
    
    // Update question number when PYQ is selected
    updateQuestionNumber();
  }
}
    // Logout functionality
    document.getElementById('logoutBtn').addEventListener('click', async () => {
      try {
        await fetch('/logout', { method: 'POST' });
        window.location.href = '/login.html';
      } catch (error) {
        console.error('Logout failed:', error);
      }
    });

    

 function renderLatex() {
  clearTimeout(previewTimeout);

  previewTimeout = setTimeout(async () => {
    const input = document.getElementById('question').value.trim();
    const preview = document.getElementById('preview');

    if (!input) {
      preview.innerHTML = '<em style="color: #777;">Preview will appear here...</em>';
      return;
    }

    // Process LaTeX content
    let processed = processLatexContent(input);
    preview.innerHTML = processed;

    // Render with MathJax
    MathJax.typesetClear([preview]);
    MathJax.typesetPromise([preview]).catch(err => {
      preview.innerHTML = '<span style="color:red;">LaTeX rendering error.</span>';
      console.error('MathJax error:', err);
    });

    // Auto-classification logic
    if (input.length > 30 && !editMode) {
      const difficultyInput = document.getElementById('difficulty');
      const difficultyStatus = document.getElementById('classificationStatus');
      
      if (!difficultyInput.value || difficultyInput.value === '') {
        if (difficultyStatus) {
          difficultyStatus.textContent = '(Classifying...)';
          difficultyStatus.style.color = '#1976d2';
        }
        
        try {
          const difficulty = await classifyDifficulty(input);
          
          if (difficulty) {
            difficultyInput.value = difficulty.charAt(0).toUpperCase() + difficulty.slice(1);
            
            if (difficultyStatus) {
              difficultyStatus.textContent = '‚úì Auto-classified';
              difficultyStatus.style.color = '#4caf50';
            }
            
            difficultyInput.style.backgroundColor = '#e8f5e9';
            setTimeout(() => {
              difficultyInput.style.backgroundColor = '#f0f0f0';
            }, 2000);
          } else {
            if (difficultyStatus) {
              difficultyStatus.textContent = '‚ùå Classification failed';
              difficultyStatus.style.color = '#f44336';
            }
          }
        } catch (error) {
          console.error('Classification error:', error);
          if (difficultyStatus) {
            difficultyStatus.textContent = '‚ùå Classification error';
            difficultyStatus.style.color = '#f44336';
          }
        }
      }
    }
  }, 800);
}


// Unified LaTeX processing function
function processLatexContent(input, isSolution = false) {
  // First, escape HTML to prevent XSS
  let escaped = input.replace(/&/g, '&amp;')
                     .replace(/</g, '&lt;')
                     .replace(/>/g, '&gt;');
  
  if (isSolution) {
    // Handle newlines for solution preview
    escaped = escaped.replace(/\n/g, '<br>');
  }
  
  // Handle various LaTeX formats
  escaped = escaped.replace(/\$\$([\s\S]+?)\$\$/g, (_, match) => `\$$${match.trim().replace(/\n/g, ' ')}\$$`);
  escaped = escaped.replace(/\\$$(.+?)\\$$/gs, (_, match) => `\$$${match.trim().replace(/\n/g, ' ')}\$$`);
  escaped = escaped.replace(/(?<!\$)\$(?!\$)(.+?)(?<!\$)\$(?!\$)/gs, (_, match) => `\$$${match.trim().replace(/\n/g, ' ')}\$$`);
  escaped = escaped.replace(/\\$$(.+?)\\$$/gs, (_, match) => `\$$${match.trim().replace(/\n/g, ' ')}\$$`);
  
  return escaped;
}

function renderOptionLatex(num) {
  const input = document.getElementById(`option${num}`).value.trim();
  const preview = document.getElementById(`preview-option${num}`);

  if (!input) {
    preview.innerHTML = '<em style="color:#777;">Preview...</em>';
    return;
  }

  // Process LaTeX content
  let processed = processLatexContent(input);
  preview.innerHTML = processed;

  // Render with MathJax
  MathJax.typesetClear([preview]);
  MathJax.typesetPromise([preview]).catch(err => {
    preview.innerHTML = '<span style="color:red;">LaTeX rendering error.</span>';
    console.error(`MathJax error for option ${num}:`, err);
  });
}

// Unified LaTeX processing function
function showSuccess() {
      const msg = document.getElementById("successMessage");
      msg.textContent = "‚úÖ Question submitted successfully!";
      msg.style.color = "green";
      setTimeout(() => (msg.textContent = ""), 3000);
      return true;
    }

    function clearForm() {
  document.getElementById('mcqForm').reset();
  document.getElementById('preview').innerHTML = '';
  // Clear option previews
  for (let i = 1; i <= 4; i++) {
    document.getElementById(`preview-option${i}`).innerHTML = '';
  }
  document.getElementById('solution-preview').innerHTML = '<em style="color: #777;">Solution preview will appear here...</em>';
  // Reset difficulty field
  document.getElementById('difficulty').value = '';
  document.getElementById('difficulty').placeholder = 'Will be auto-classified...';
  if (document.getElementById('classificationStatus')) {
    document.getElementById('classificationStatus').textContent = '';
  }
  // Hide PYQ details
  document.getElementById('pyqDetails').style.display = 'none';
  // Clear exam date options
  document.getElementById('examDate').innerHTML = '<option value="">-- Select Exam Date --</option>';
  
  // Reset question number field
  const questionNoInput = document.getElementById('questionNo');
  questionNoInput.value = '';
  questionNoInput.readOnly = false;
  questionNoInput.style.backgroundColor = '';
  questionNoInput.style.cursor = '';
  questionNoInput.placeholder = 'e.g., Q1, 1, A-1, etc.';
  
  // Hide cancel button if in edit mode
  const cancelBtn = document.getElementById('cancelEditBtn');
  if (cancelBtn) {
    cancelBtn.style.display = editMode ? 'inline-block' : 'none';
  }
}
    function updateTopics() {
      const subject = document.getElementById("subject").value;
      const topicSelect = document.getElementById("topic");
      topicSelect.innerHTML = "";

      let topics = [];
      if (subject === "Physics") topics = physicsTopics;
      else if (subject === "Chemistry") topics = chemistryTopics;
      else if (subject === "Maths") topics = mathsTopics;

      const defaultOption = document.createElement("option");
      defaultOption.value = "";
      defaultOption.textContent = "-- Select Topic --";
      topicSelect.appendChild(defaultOption);

      topics.forEach((topic) => {
        const option = document.createElement("option");
        option.value = topic;
        option.textContent = topic;
        topicSelect.appendChild(option);
      });
    }

    const form = document.getElementById('mcqForm');

    // Form submission handler
    form.addEventListener('submit', async function(event) {
      event.preventDefault();

      const formData = new FormData(form);
      const data = {
        questionNo: formData.get('questionNo'),
        question: formData.get('question'),
        options: [
          formData.get('option1'),
          formData.get('option2'),
          formData.get('option3'),
          formData.get('option4')
        ],
        correctOption: formData.get('correctOption'),
        subject: formData.get('subject'),
        topic: formData.get('topic'),
        difficulty: formData.get('difficulty').toLowerCase(),
        solution: formData.get('solution') || '', // Ensure lowercase
        pyqType: formData.get('pyqType'),
        shift: formData.get('shift') || 'N/A',
        year: formData.get('year') ? parseInt(formData.get('year')) : null,
        examDate: formData.get('examDate') || null,
        autoClassified: wasAutoClassified // Add this
      };

      // Validate difficulty
      if (!data.difficulty || !['easy', 'medium', 'hard'].includes(data.difficulty)) {
        alert('Please wait for difficulty classification or enter manually (easy/medium/hard)');
        return;
      }

      try {
        let response;
        let successMessage;

        if (editMode && editingQuestionId) {
          // Update existing question
          response = await fetch(`/questions/${editingQuestionId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data),
          });
          successMessage = 'Question updated successfully!';
        } else {
          // Create new question
          response = await fetch('/submit', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data),
          });
          successMessage = 'Question added successfully!';
        }

        if (response.ok) {
          alert(successMessage);
          cancelEdit(); // This will clear form and reset edit mode
          loadQuestions(); // Reload questions to show updated data
        } else {
          const errorText = await response.text();
          alert('Failed to save question: ' + errorText);
        }
      } catch (error) {
        alert('Error: ' + error.message);
      }
      wasAutoClassified = false;
    });
function initializeFilters() {
  console.log('Initializing filters...');
  
  // Show creator filter for superusers
  if (currentUser && currentUser.role === 'superuser') {
    const creatorFilterGroup = document.getElementById('creatorFilterGroup');
    if (creatorFilterGroup) {
      creatorFilterGroup.style.display = 'block';
    }
    loadCreators();
  }
  
  // Load years for filter
  loadFilterYears();
}
function loadCreators() {
  const creators = [...new Set(allQuestions
    .filter(q => q.createdBy && q.createdBy.username)
    .map(q => q.createdBy.username))]
    .sort();
  
  const creatorSelect = document.getElementById('filterCreator');
  if (creatorSelect) {
    creatorSelect.innerHTML = '<option value="">All Users</option>';
    
    creators.forEach(creator => {
      const option = document.createElement('option');
      option.value = creator;
      option.textContent = creator;
      creatorSelect.appendChild(option);
    });
  }
}

    // New loadQuestions function that integrates with search/filter
    // New loadQuestions function that integrates with search/filter
async function loadQuestions() {
  try {
    console.log('Starting to load questions...');
    const response = await fetch('/questions');
    
    console.log('Response status:', response.status);
    
    if (response.status === 401) {
      window.location.href = '/login.html';
      return;
    }
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    console.log('Questions loaded:', data);
    
    allQuestions = data;
    
    // Show search and filter container
    const searchFilterContainer = document.getElementById('searchFilterContainer');
    if (searchFilterContainer) {
      searchFilterContainer.style.display = 'flex';
    }
    
    if (allQuestions.length === 0) {
      document.getElementById('questionList').innerHTML = '<p>No questions found.</p>';
      const resultsSummary = document.getElementById('resultsSummary');
      if (resultsSummary) {
        resultsSummary.style.display = 'none';
      }
      return;
    }

    // Initialize filters on first load
    initializeFilters();
    
    // Display all questions initially
    filteredQuestions = [...allQuestions];
    displayFilteredQuestions();
    updateResultsSummary();
    
  } catch (error) {
    console.error('Detailed error loading questions:', error);
    console.error('Error stack:', error.stack);
    
    // More specific error message
    const errorMessage = error.message || 'Unknown error occurred';
    alert(`Error loading questions: ${errorMessage}. Please check the console for details.`);
    
    // Still try to show the question list container
    const questionList = document.getElementById('questionList');
    if (questionList) {
      questionList.innerHTML = `<p style="color: red;">Error loading questions: ${errorMessage}</p>`;
    }
  }
}
    // Load years for filter dropdown
    function loadFilterYears() {
      const years = [...new Set(allQuestions
        .filter(q => q.year)
        .map(q => q.year))]
        .sort((a, b) => b - a);
      
      const yearSelect = document.getElementById('filterYear');
      if (yearSelect) {
        yearSelect.innerHTML = '<option value="">All Years</option>';
        
        years.forEach(year => {
          const option = document.createElement('option');
          option.value = year;
          option.textContent = year;
          yearSelect.appendChild(option);
        });
      }
    }

    // Update topic filter based on selected subject
    function updateTopicFilter() {
      const selectedSubject = document.getElementById('filterSubject').value;
      const topicSelect = document.getElementById('filterTopic');
      
      if (!topicSelect) return;
      
      topicSelect.innerHTML = '<option value="">All Topics</option>';
      
      if (!selectedSubject) return;
      
      let topics = [];
      if (selectedSubject === 'Physics') topics = physicsTopics;
      else if (selectedSubject === 'Chemistry') topics = chemistryTopics;
      else if (selectedSubject === 'Maths') topics = mathsTopics;
      
      topics.forEach(topic => {
        const option = document.createElement('option');
        option.value = topic;
        option.textContent = topic;
        topicSelect.appendChild(option);
      });
    }

    // Toggle filter section visibility
    function toggleFilters() {
      const filterSection = document.getElementById('filterSection');
      const toggleIcon = document.getElementById('filterToggleIcon');
      
      if (filterSection.style.display === 'none') {
        filterSection.style.display = 'block';
        toggleIcon.textContent = '‚ñ≤';
      } else {
        filterSection.style.display = 'none';
        toggleIcon.textContent = '‚ñº';
      }
    }

    // Search functionality
    function searchQuestions() {
      const searchInput = document.getElementById('searchInput');
      if (searchInput) {
        const searchTerm = searchInput.value.toLowerCase().trim();
        currentSearchTerm = searchTerm;
        applyFilters();
      }
    }

    // Clear search
    function clearSearch() {
      const searchInput = document.getElementById('searchInput');
      if (searchInput) {
        searchInput.value = '';
        currentSearchTerm = '';
        applyFilters();
      }
    }

    // Apply all filters and search
    function applyFilters() {
      // Get filter values
      activeFilters = {
        subject: document.getElementById('filterSubject')?.value || '',
        topic: document.getElementById('filterTopic')?.value || '',
        difficulty: document.getElementById('filterDifficulty')?.value || '',
        pyqType: document.getElementById('filterPyqType')?.value || '',
        year: document.getElementById('filterYear')?.value || '',
        creator: document.getElementById('filterCreator')?.value || '',
        sortBy: document.getElementById('sortBy')?.value || 'createdAt-desc'
      };

      // Start with all questions
      filteredQuestions = [...allQuestions];

      // Apply filters
      if (activeFilters.subject) {
        filteredQuestions = filteredQuestions.filter(q => q.subject === activeFilters.subject);
      }

      if (activeFilters.topic) {
        filteredQuestions = filteredQuestions.filter(q => q.topic === activeFilters.topic);
      }

      if (activeFilters.difficulty) {
        filteredQuestions = filteredQuestions.filter(q => q.difficulty === activeFilters.difficulty);
      }

      if (activeFilters.pyqType) {
        filteredQuestions = filteredQuestions.filter(q => q.pyqType === activeFilters.pyqType);
      }

      if (activeFilters.year) {
        filteredQuestions = filteredQuestions.filter(q => q.year === parseInt(activeFilters.year));
      }

      if (activeFilters.creator && currentUser.role === 'superuser') {
        filteredQuestions = filteredQuestions.filter(q => 
          q.createdBy && q.createdBy.username === activeFilters.creator
        );
      }

      // Apply search
      if (currentSearchTerm) {
        filteredQuestions = filteredQuestions.filter(q => {
          const searchableText = [
            q.questionNo || '',
            q.question || '',
            ...(q.options || []),
            q.subject || '',
            q.topic || '',
            q.difficulty || '',
            q.pyqType || ''
          ].join(' ').toLowerCase();
          
          return searchableText.includes(currentSearchTerm);
        });
      }

      // Apply sorting
      const [sortField, sortOrder] = activeFilters.sortBy.split('-');
      filteredQuestions.sort((a, b) => {
        let compareValue = 0;
        
        switch(sortField) {
          case 'createdAt':
            compareValue = new Date(a.createdAt) - new Date(b.createdAt);
            break;
          case 'questionNo':
            compareValue = (a.questionNo || '').localeCompare(b.questionNo || '');
            break;
          case 'difficulty':
            const difficultyOrder = { easy: 1, medium: 2, hard: 3 };
            compareValue = (difficultyOrder[a.difficulty] || 0) - (difficultyOrder[b.difficulty] || 0);
            break;
        }
        
        return sortOrder === 'desc' ? -compareValue : compareValue;
      });

      // Update UI
      displayFilteredQuestions();
      updateFilterCount();
      updateResultsSummary();
    }
    // Highlight search terms in text
function highlightSearchTerm(text) {
  if (!currentSearchTerm || !text) return text;
  
  // Escape special regex characters
  const escapedTerm = currentSearchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const regex = new RegExp(`(${escapedTerm})`, 'gi');
  return text.replace(regex, '<span class="search-highlight">$1</span>');
}

    // Display filtered questions
    // Display filtered questions
// Display filtered questions
function displayFilteredQuestions() {
    const list = document.getElementById('questionList');
    if (!list) return;

    list.innerHTML = '';

    if (filteredQuestions.length === 0) {
        list.innerHTML = '<p>No questions match your search/filters.</p>';
        return;
    }

    filteredQuestions.forEach((q, i) => {
        const div = document.createElement('div');
        div.className = 'question-card';

        let creatorInfo = '';
        if (currentUser.role === 'superuser' && q.createdBy) {
            const createdDate = new Date(q.createdAt);
            const formattedDateTime = createdDate.toLocaleString('en-US', {
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: true
            });
            creatorInfo = `
                <div class="creator-info">
                    <div><strong>Created by:</strong> ${q.createdBy.username || 'Unknown'}</div>
                    <div><strong>Created on:</strong> ${formattedDateTime}</div>
                </div>
            `;
        }

        let pyqInfo = '';
        if (q.pyqType && q.pyqType !== 'Not PYQ') {
            pyqInfo = `<div class="pyq-info">
                <strong>PYQ:</strong> ${q.pyqType}
                ${q.examDate ? ` - ${new Date(q.examDate).toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                })}` : ''}
                ${q.shift && q.shift !== 'N/A' ? ` - ${q.shift}` : ''}
            </div>`;
        }

        let actionButtons = '';
        if (currentUser.role === 'superuser') {
            actionButtons = `
                <div class="action-buttons">
                    <button onclick="editQuestion('${q._id}')" class="edit-btn">‚úèÔ∏è Edit</button>
                    <button onclick="deleteQuestion('${q._id}')" class="delete-btn">üóëÔ∏è Delete</button>
                </div>
            `;
        }

        const classificationBadge = q.autoClassified ? 
            '<span class="badge auto-classified">ü§ñ Auto-classified</span>' : '';

        // Process question text with LaTeX
        const processedQuestion = processTextForDisplay(q.question);

        // Process options with LaTeX
        const processedOptions = q.options.map((opt, idx) => {
            const processedOpt = processTextForDisplay(opt);
            const isCorrect = idx === q.correctOption;
            const optionLetter = String.fromCharCode(65 + idx);
            return `<li data-option="${optionLetter}"${isCorrect ? ' style="font-weight:bold;color:green;"' : ''}>${processedOpt}</li>`;
        }).join('');

        // Process solution if exists
        const processedSolution = q.solution ? processTextForDisplay(q.solution) : '';

        div.innerHTML = `
            <div class="question-header">
                <strong>Question No: ${highlightSearchTerm(q.questionNo)}</strong>
            </div>
            <div class="question-content">
                <strong>Q${i + 1}:</strong> <span class="question-text-inline">${processedQuestion}</span>
                <ul>${processedOptions}</ul>
                <div class="question-meta">
                    <em>Subject:</em> ${q.subject}, 
                    <em>Topic:</em> ${q.topic}, 
                    <em>Difficulty:</em> ${q.difficulty}
                    ${classificationBadge}
                </div>
                ${pyqInfo}
                ${q.solution ? `
                    <div class="solution-section">
                        <strong>Solution:</strong>
                        <div class="solution-content">
                            ${processedSolution}
                        </div>
                    </div>
                ` : ''}
                ${creatorInfo}
            </div>
            ${actionButtons}
        `;

        list.appendChild(div);
    });

    // Render MathJax for all questions
    if (window.MathJax) {
        MathJax.typesetClear([list]);
        MathJax.typesetPromise([list]).then(() => {
            console.log('MathJax rendering complete for question list');
            
            // Force inline display for equations
            document.querySelectorAll('.question-card .MathJax_Display').forEach(el => {
                el.style.display = 'inline';
                el.style.textAlign = 'left';
                el.style.margin = '0 0.3em';
                el.style.width = 'auto';
            });
        }).catch((err) => {
            console.error('MathJax rendering error:', err);
        });
    }
}// Add this helper function to process LaTeX for display
// Add this helper function to process LaTeX for display
// Add this helper function to process LaTeX for display
function processTextForDisplay(text) {
    if (!text) return '';
    
    // HTML escape
    let processed = text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
    
    // Support newlines in solutions
    processed = processed.replace(/\n/g, '<br>');
    
    // Process display math - convert to inline for question display
    processed = processed.replace(/\$\$([\s\S]+?)\$\$/g, (_, match) => {
        // Use single $ for inline rendering in question list
        return `$${match.trim()}$`;
    });
    
    // Process inline math
    processed = processed.replace(/\$([^\$]+?)\$/g, (_, match) => `\$$${match.trim()}\$$`);
    
    // Apply search highlighting if needed
    if (currentSearchTerm) {
        const escapedTerm = currentSearchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const regex = new RegExp(`(${escapedTerm})`, 'gi');
        processed = processed.replace(regex, (match, p1, offset, string) => {
            const beforeMatch = string.substring(0, offset);
            const dollarSignsBefore = (beforeMatch.match(/\$/g) || []).length;
            if (dollarSignsBefore % 2 === 1) {
                return match;
            }
            return '<span class="search-highlight">' + match + '</span>';
        });
    }
    
    return processed;
}   
 // Update active filter count
    function updateFilterCount() {
      let count = 0;
      
      if (activeFilters.subject) count++;
      if (activeFilters.topic) count++;
      if (activeFilters.difficulty) count++;
      if (activeFilters.pyqType) count++;
      if (activeFilters.year) count++;
      if (activeFilters.creator) count++;
      
      const filterCountElement = document.getElementById('activeFilterCount');
      if (filterCountElement) {
        if (count > 0) {
          filterCountElement.textContent = count;
          filterCountElement.style.display = 'inline-block';
        } else {
          filterCountElement.style.display = 'none';
        }
      }
    }

    // Update results summary
    function updateResultsSummary() {
      const summaryDiv = document.getElementById('resultsSummary');
      const countSpan = document.getElementById('resultsCount');
      const searchSummarySpan = document.getElementById('searchSummary');
      
      if (!summaryDiv || !countSpan) return;
      
      summaryDiv.style.display = 'block';
      countSpan.textContent = filteredQuestions.length;
      
      if (currentSearchTerm && searchSummarySpan) {
        searchSummarySpan.textContent = ` matching "${currentSearchTerm}"`;
      } else if (searchSummarySpan) {
        searchSummarySpan.textContent = '';
      }
    }

    // Reset all filters
    function resetFilters() {
      // Reset form values
      document.getElementById('filterSubject').value = '';
      document.getElementById('filterTopic').value = '';
      document.getElementById('filterDifficulty').value = '';
      document.getElementById('filterPyqType').value = '';
      document.getElementById('filterYear').value = '';
      document.getElementById('sortBy').value = 'createdAt-desc';
      
      const creatorFilter = document.getElementById('filterCreator');
      if (creatorFilter) {
        creatorFilter.value = '';
      }
      
      // Reset search
      document.getElementById('searchInput').value = '';
      currentSearchTerm = '';
      
      // Reset topic dropdown
      document.getElementById('filterTopic').innerHTML = '<option value="">All Topics</option>';
      
      // Apply filters (which will now show all questions)
      applyFilters();
    }
        // Function to load years from backend
    async function loadYears() {
      try {
        console.log('Loading years...');
        
        // Use appropriate endpoint based on user role
        const endpoint = currentUser && currentUser.role === 'superuser' 
          ? '/admin/years' 
          : '/public/years';
        
        const response = await fetch(endpoint);
        console.log('Response status:', response.status);
        
        if (response.ok) {
          const years = await response.json();
          console.log('Years received from backend:', years);
          
          // Only update admin dropdowns for superusers
          if (currentUser && currentUser.role === 'superuser') {
            updateYearDropdowns(years);
            displayCurrentYears(years);
          }
          
          // Always update main PYQ dropdown
          updateMainPyqYearDropdown(years);
        } else {
          console.error('Failed to load years:', response.status);
          const defaultYears = [2025, 2024, 2023, 2022, 2021];
          updateMainPyqYearDropdown(defaultYears);
        }
      } catch (error) {
        console.error('Error loading years:', error);
        const defaultYears = [2025, 2024, 2023, 2022, 2021];
        updateMainPyqYearDropdown(defaultYears);
      }
    }
function processSolutionLatex(solution) {
  if (!solution) return '';
  
  let processed = solution
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/\n/g, '<br>');
  
  // Process display math
  processed = processed.replace(/\$\$([\s\S]+?)\$\$/g, (_, match) => `\$$${match.trim()}\$$`);
  
  // Process inline math
  processed = processed.replace(/\$([^\$]+?)\$/g, (_, match) => `\$$${match.trim()}\$$`);
  
  return processed;
}
    // Function to update the main PYQ year dropdown
    function updateMainPyqYearDropdown(yearsData) {
      const mainYearSelect = document.getElementById('year');
      
      // Handle both array and object with years property
      let years = Array.isArray(yearsData) ? yearsData : (yearsData.years || []);
      
      console.log('Updating main PYQ dropdown with years:', years);
      
      // Store currently selected value
      const currentValue = mainYearSelect.value;
      
      // Clear existing options
      mainYearSelect.innerHTML = '<option value="">-- Select Year --</option>';
      
      // Add years to main dropdown (sort in descending order for better UX)
      years.sort((a, b) => b - a).forEach(year => {
        const option = document.createElement('option');
        option.value = year;
        option.textContent = year;
        mainYearSelect.appendChild(option);
      });
      
      // Restore previously selected value if it still exists
      if (currentValue && years.includes(parseInt(currentValue))) {
        mainYearSelect.value = currentValue;
      }
    }

    // Function to update year dropdowns (admin panel only)
    function updateYearDropdowns(yearsData) {
      const dateManagementYear = document.getElementById('dateManagementYear');
      
      // Handle both array and object with years property
      let years = Array.isArray(yearsData) ? yearsData : (yearsData.years || []);
      
      // Clear existing options
      dateManagementYear.innerHTML = '<option value="">Select Year</option>';
      
      // Add years to admin dropdown
      years.sort((a, b) => b - a).forEach(year => {
        const option = document.createElement('option');
        option.value = year;
        option.textContent = year;
        dateManagementYear.appendChild(option);
      });
    }

    function displayCurrentYears(yearsData) {
      const yearsList = document.getElementById('yearsList');
      yearsList.innerHTML = '';
      
      // Handle both array and object with years property
      let years = Array.isArray(yearsData) ? yearsData : (yearsData.years || []);
      
      console.log('Displaying current years:', years);
      
      years.forEach(year => {
        const yearItem = document.createElement('div');
        yearItem.className = 'year-item';
        yearItem.innerHTML = `
          <span>${year}</span>
          <button onclick="removeYear(${year})" class="admin-btn delete-btn">‚ùå Remove</button>
        `;
        yearsList.appendChild(yearItem);
      });
    }

    // Function to add a new year
    async function addYear() {
      const newYearInput = document.getElementById('newYear');
      const year = parseInt(newYearInput.value);
      
      if (!year || year < 1000) {
        alert('Please enter a valid 4-digit year');
        return;
      }
      
      try {
        const response = await fetch('/admin/years', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ year })
        });
        
        if (response.ok) {
          alert('Year added successfully!');
          newYearInput.value = '';
          
          // Add a small delay before reloading to ensure backend has saved the data
          setTimeout(() => {
            loadYears();
          }, 500);
        } else {
          const error = await response.json();
          alert('Error: ' + error.error);
        }
      } catch (error) {
        console.error('Error adding year:', error);
        alert('Error adding year');
      }
    }

    // Function to remove a year
    async function removeYear(year) {
      if (!confirm(`Are you sure you want to remove year ${year}?`)) {
        return;
      }
      
      try {
        const response = await fetch(`/admin/years/${year}`, {
          method: 'DELETE'
        });
        
        if (response.ok) {
          alert('Year removed successfully!');
          loadYears(); // This will now update both admin and main dropdowns
          
          // Clear exam date dropdown if the removed year was selected
          const mainYearSelect = document.getElementById('year');
          if (parseInt(mainYearSelect.value) === year) {
            document.getElementById('examDate').innerHTML = '<option value="">-- Select Exam Date --</option>';
          }
        } else {
          const error = await response.json();
          alert('Error: ' + error.error);
        }
      } catch (error) {
        console.error('Error removing year:', error);
        alert('Error removing year');
      }
    }

    // Function to load exam dates for selected year
    async function loadExamDatesForYear() {
      const year = document.getElementById('dateManagementYear').value;
      if (!year) {
        document.getElementById('examDatesList').innerHTML = '';
        return;
      }
      
      try {
        // Admin panel should use the public endpoint too, or create a separate admin endpoint
        const response = await fetch(`/public/exam-dates/${year}`);
        if (response.ok) {
          const examDates = await response.json();
          displayExamDates(examDates, year);
        }
      } catch (error) {
        console.error('Error loading exam dates:', error);
      }
    }

    // Function to display exam dates
    function displayExamDates(examDates, year) {
      const examDatesList = document.getElementById('examDatesList');
      examDatesList.innerHTML = '';
      
      examDates.forEach(dateObj => {
        const dateItem = document.createElement('div');
        dateItem.className = 'exam-date-item';
        dateItem.innerHTML = `
          <span>${dateObj.label}</span>
          <button onclick="removeExamDate('${year}', '${dateObj.date}')" class="admin-btn delete-btn">‚ùå Remove</button>
        `;
        examDatesList.appendChild(dateItem);
      });
    }

    // Function to add exam date
    async function addExamDate() {
      const year = document.getElementById('dateManagementYear').value;
      const date = document.getElementById('newExamDate').value;
      
      if (!year || !date) {
        alert('Please select a year and date');
        return;
      }
      
      try {
        const response = await fetch('/admin/exam-dates', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ year: parseInt(year), date })
        });
        
        if (response.ok) {
          alert('Exam date added successfully!');
          document.getElementById('newExamDate').value = '';
          loadExamDatesForYear(); // Reload exam dates
          populateExamDates(); // Update the main form's exam dates
        } else {
          const error = await response.json();
          alert('Error: ' + error.error);
        }
      } catch (error) {
        console.error('Error adding exam date:', error);
        alert('Error adding exam date');
      }
    }

    // Function to remove exam date
    async function removeExamDate(year, date) {
      if (!confirm('Are you sure you want to remove this exam date?')) {
        return;
      }
      
      try {
        const response = await fetch('/admin/exam-dates', {
          method: 'DELETE',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ year: parseInt(year), date })
        });
        
        if (response.ok) {
          alert('Exam date removed successfully!');
          loadExamDatesForYear(); // Reload exam dates
          populateExamDates(); // Update the main form's exam dates
        } else {
          const error = await response.json();
          alert('Error: ' + error.error);
        }
      } catch (error) {
        console.error('Error removing exam date:', error);
        alert('Error removing exam date');
      }
    }

    // Function to show/hide admin section
    function toggleAdminSection() {
      const adminSection = document.getElementById('adminSection');
      const toggleBtn = document.getElementById('adminToggleBtn');
      
      if (adminSection.style.display === 'none') {
        adminSection.style.display = 'block';
        toggleBtn.style.display = 'none';
        // Reload years when opening admin panel to ensure fresh data
        if (currentUser.role === 'superuser') {
          loadYears();
        }
      } else {
        adminSection.style.display = 'none';
        toggleBtn.style.display = 'block';
      }
    }

    // Function to classify difficulty using the external API
    async function classifyDifficulty(question) {
      try {
        const response = await fetch(`${CLASSIFIER_API_URL}/classify`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            session_id: `mcq-${currentUser.username}-${Date.now()}`,
            question: question
          })
        });

        if (!response.ok) {
          throw new Error('Classification failed');
        }

        const data = await response.json();
        wasAutoClassified = true; // Set flag
        return data.difficulty.toLowerCase();
      } catch (error) {
        console.error('Error classifying difficulty:', error);
        wasAutoClassified = false;
        return null;
      }
    }

    // Add auto-classification status indicator
    function addClassificationStatus() {
      // Status is already added in the HTML, no need to modify DOM
    }

    // Manual re-classification function
    async function reclassifyDifficulty() {
      const question = document.getElementById('question').value;
      if (!question || question.trim().length < 20) {
        alert('Please enter a complete question first (at least 20 characters)');
        return;
      }

      const difficultyInput = document.getElementById('difficulty');
      const difficultyStatus = document.getElementById('classificationStatus');
      
      // Clear current value
      difficultyInput.value = '';
      
      if (difficultyStatus) {
        difficultyStatus.textContent = '(Re-classifying...)';
        difficultyStatus.style.color = '#1976d2';
      }
      
      const difficulty = await classifyDifficulty(question);
      
      if (difficulty) {
        difficultyInput.value = difficulty.charAt(0).toUpperCase() + difficulty.slice(1);
        
        if (difficultyStatus) {
                   difficultyStatus.textContent = '‚úì Re-classified';
          difficultyStatus.style.color = '#4caf50';
        }
        
        // Visual feedback
        difficultyInput.style.backgroundColor = '#e8f5e9';
        setTimeout(() => {
          difficultyInput.style.backgroundColor = '#f0f0f0';
        }, 2000);
      } else {
        if (difficultyStatus) {
          difficultyStatus.textContent = '‚ùå Classification failed - enter manually';
          difficultyStatus.style.color = '#f44336';
        }
        
        // Allow manual input if classification fails
        difficultyInput.readOnly = false;
        difficultyInput.style.backgroundColor = '#fff';
        difficultyInput.style.cursor = 'text';
        difficultyInput.placeholder = 'Enter: easy, medium, or hard';
      }
    }

    // Setup batch classification for superusers
    function setupBatchClassification() {
      if (currentUser.role === 'superuser') {
        const adminSection = document.getElementById('adminSection');
        if (adminSection) {
          // Check if batch classification section already exists
          if (!document.getElementById('batchClassificationSection')) {
            // Add batch classification section
            const batchClassifyDiv = document.createElement('div');
            batchClassifyDiv.id = 'batchClassificationSection';
            batchClassifyDiv.className = 'admin-card';
            batchClassifyDiv.innerHTML = `
              <h3>ü§ñ Batch Difficulty Classification</h3>
              <div class="admin-controls">
                <p>Automatically classify difficulty for questions without difficulty set.</p>
                <button onclick="batchClassifyQuestions()" class="admin-btn">
                  üöÄ Start Batch Classification
                </button>
                <div id="batchProgress" style="display: none; margin-top: 10px;">
                  <div class="progress-bar">
                    <div id="progressFill" style="width: 0%; height: 20px; background: #4caf50;"></div>
                  </div>
                  <p id="progressText">Processing...</p>
                </div>
              </div>
            `;
            adminSection.appendChild(batchClassifyDiv);
          }
        }
      }
    }

    // Batch classification function
    async function batchClassifyQuestions() {
      if (!confirm('This will classify all questions without a difficulty level. Continue?')) {
        return;
      }
      
      const progressDiv = document.getElementById('batchProgress');
      const progressFill = document.getElementById('progressFill');
      const progressText = document.getElementById('progressText');
      
      progressDiv.style.display = 'block';
      
      try {
        // Load all questions
        const response = await fetch('/questions');
        const questions = await response.json();
        
        // Filter questions without difficulty
        const questionsToClassify = questions.filter(q => !q.difficulty || q.difficulty === '');
        
        if (questionsToClassify.length === 0) {
          alert('All questions already have difficulty levels assigned!');
          progressDiv.style.display = 'none';
          return;
        }
        
        let processed = 0;
        let successful = 0;
        
        for (const question of questionsToClassify) {
          progressText.textContent = `Processing ${processed + 1} of ${questionsToClassify.length}...`;
          
          const difficulty = await classifyDifficulty(question.question);
          
          if (difficulty) {
            // Update the question
            const updateResponse = await fetch(`/questions/${question._id}`, {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                ...question,
                difficulty: difficulty,
                autoClassified: true
              })
            });
            
            if (updateResponse.ok) {
              successful++;
            }
          }
          
          processed++;
          progressFill.style.width = `${(processed / questionsToClassify.length) * 100}%`;
          
          // Add delay to avoid overwhelming the API
          await new Promise(resolve => setTimeout(resolve, 500));
        }
        
        progressText.textContent = `Complete! Successfully classified ${successful} out of ${questionsToClassify.length} questions.`;
        
        // Reload questions after batch processing
        setTimeout(() => {
          progressDiv.style.display = 'none';
          loadQuestions();
        }, 3000);
        
      } catch (error) {
        console.error('Batch classification error:', error);
        progressText.textContent = 'Error during batch classification.';
      }
    }
  </script>
  
</body>
</html>